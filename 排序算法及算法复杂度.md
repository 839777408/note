---
title: 排序算法及算法复杂度
tags:
  - 时间复杂度
categories:
  - Java
  - 数据结构和算法
top_img: 'https://npm.elemecdn.com/nan-picture@1.0.0/img/wp8.jpg'
cover: 'https://npm.elemecdn.com/nan-picture@1.0.0/img/wp8.jpg'
abbrlink: '9761'
date: 2020-07-29 16:52:34
updated: 2020-07-29 16:52:34
---

# 排序算法

## 排序的介绍

排序也称排序算法（Sort Algorithm），排序是将一组数据，依指定的顺序进行排列的过程。

## 排序的稳定性

**未排序前：**

| 编号 | 姓名   | 总分 |
| ---- | ------ | ---- |
| 1    | 令狐冲 | 753  |
| 2    | 郭靖   | 573  |
| 3    | 杨过   | 682  |
| 4    | 张无忌 | 753  |

**排序后：**

| 编号 | 姓名   | 总分 |
| ---- | ------ | ---- |
| 1    | 令狐冲 | 753  |
| 4    | 张无忌 | 753  |
| 3    | 杨过   | 682  |
| 2    | 郭靖   | 573  |

如上所示，经过对总分的降序排序后，总分高的排在前列。

此时对于令狐冲和张无忌而言，未排序前是令狐冲在前，那么他们总分排序后，分数相等的令狐冲应该依然在前，这样才算是稳定的排序。如果他们二者颠倒了，则此排序是不稳定的了。

只要有一组关键字实例发生颠倒情况，就可认为此排序方法是不稳定的。排序算法是否稳定的，要通过分析后才能得出。

## 排序的分类

**内排序**是在排序整个过程中，待排序的所有记录全部被放置在内存中。

**外排序**是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。

![](https://npm.elemecdn.com/nan-picture@1.0.0/blog/20200729172733.png)



# 算法的时间复杂度

## 算法效率的度量方法

**事后统计方法：**这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。

**缺陷：**

1. 必须依据算法事先编制好程序，这通常需要花费大量的时间和精力。
2. 时间的比较依赖计算机硬件和软件等环境因素，有时会掩盖算法本身的优劣。
3. 算法的测试数据设计困难，并且程序的运行时间往往还与测试数据的规模有很大关系，效率高的算法在小的测试数据面前往往得不到体现。

**事前分析估算方法：**通过分析某个**算法的时间复杂度**来判断哪个算法更优。

## 时间复杂度的定义

​        一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) )  为算法的渐进时间复杂度，简称时间复杂度。

​		这样用大写O（）来体现算法时间复杂度的记法，我们称之为**大O记法**。

​		一般情况下，随着n的增大，T（n）增长最慢的算法为最优算法。

​		T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。

## 计算时间复杂度的方法

>1. 用常数1代替运行时间中的所有加法常数  T(n)=n²+7n+**6**  => T(n)=n²+7n+**1**
>
>2. 修改后的运行次数函数中，只保留最高阶项  T(n)=**n²**+7n+1 => T(n) = **n²**
>
>3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。
>
>   得到的结果就是大O阶。 T(n)=**2**n² =>  T(n) = n²=>  O(n²)

## 常见的时间复杂度

> 常数阶O(1)
> 对数阶O(log<sub>2</sub>n)
> 线性阶O(n)
> 线性对数阶O(nlog<sub>2</sub>n)
> 平方阶O(n<sup>2</sup>)
> 立方阶O(n<sup>3</sup>)
> k次方阶O(n<sup>k</sup>)
> 指数阶O(2<sup>n</sup>)

常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log<sub>2</sub>n)＜Ο(n)＜Ο(nlog<sub>2</sub>n)＜Ο(n<sup>2</sup>)＜Ο(n<sup>3</sup>)＜ Ο(n<sup>k</sup>) ＜Ο(2<sup>n</sup>) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。

## 常数阶O(1)

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)

```java
int i = 1;
int j = 2;
j++;
i++;
int m = i + j;
```

说明：上述代码在执行的时候，它消耗的时间并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

## 对数阶O(log<sub>2</sub>n)

```java
int i = 1;
while(i<n){
    i = i * 2 ;
}
```

说明：在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 n 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x =log<sub>2</sub>n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log<sub>2</sub>n)  。 O((log<sub>2</sub>n) 的这个2 时间上是根据代码变化的，i = i * 3时 ，则是 O((log<sub>3</sub>n) 。

> 如果N=a<sup>x</sup>（a>0，a≠1），即a的x次方等于N（a>0，且a≠1），那么数x叫做以a为底N的对数（logarIthm），记作x=log<sub>a</sub>N。其中，a叫做对数的底数，N叫做真数，x叫做以a为底N的对数。

## 线性阶O(n)

```java
for(int i = 0; i<=n; i++){
	j = i;
	j++;
}
```

说明：这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度

## 线性对数阶O(nlogN)

```java
for(int m = 1; m<=n; m++){
	i = 1;
	int i = 1;
	while(i<n){
   	 i = i * 2 ;
	}
}
```

说明：线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)

## 平方阶O(n²)

```java
for(int x = 1; x<=n; x++){
	for(int i = 1; i<=n; i++){
        j = i;
        j++;
	}
}
```

说明：平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n x n)，即  O(n²)。 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m x n)



# 平均时间复杂度和最坏时间复杂度

- 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
- 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。
- 平均时间复杂度和最坏时间复杂度是否一致，和算法有关。

| 排序算法 | 平均时间         | 最差时间                | 稳定性 | 空间复杂度 | 备注                                         |
| -------- | ---------------- | ----------------------- | ------ | ---------- | -------------------------------------------- |
| 冒泡排序 | O(n²)            | O(n²)                   | 稳定   | O(1)       | n较小时好                                    |
| 交换排序 | On²)             | O(n²)                   | 不稳定 | O(1)       | n较小时好                                    |
| 选择排序 | O(n²)            | O(n²)                   | 不稳定 | O(1)       | n较小时好                                    |
| 插入排序 | O(n²)            | O(n²)                   | 稳定   | O(1)       | 大部分已有序时好                             |
| 基数排序 | O(n<sup>k</sup>) | O(n<sup>k</sup>)        | 稳定   | O(n)       | 二维数组（桶）、一维数组（桶中首元素的位置） |
| 希尔排序 | O(nlogn)         | O(n<sup>s</sup>)(1<s<2) | 不稳定 | O(1)       | s是所选分组                                  |
| 快速排序 | O(nlogn)         | O(n²)                   | 不稳定 | O(logn)    | n较大时好                                    |
| 归并排序 | O(nlogn)         | O(nlogn)                | 稳定   | O(1)       | n较大时好                                    |
| 堆排序   | O(nlogn)         | O(nlogn)                | 不稳定 | O(1)       | n较大时好                                    |

# 算法的空间复杂度

- 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。
- 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。
- 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间。